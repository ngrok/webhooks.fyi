{"pageProps":{"markdoc":{"content":[{"$$mdtype":"Tag","name":"table","attributes":{},"children":[{"$$mdtype":"Tag","name":"thead","attributes":{},"children":[]},{"$$mdtype":"Tag","name":"tbody","attributes":{},"children":[{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Complexity"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Medium"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Pros"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Mitigates replay attacks by adding a signed timestamp to the webhook request"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Caveats"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Requires webhook provider and consumers to have a clock in sync (or close to)"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Requires alignment in time format — i.e. UNIX timestamp or RFC 3339 and time zones for the proper validation"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Timestamps can be sent in the same header as hash signatures or in a dedicated timestamp header"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Examples"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.8x8.com/contactcenter/docs/verify-webhook-callbacks"},"children":["8x8"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.calendly.com/api-docs/ZG9jOjM2MzE2MDM4-webhook-signatures"},"children":["Calendly"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://api.slack.com/authentication/verifying-requests-from-slack"},"children":["Slack"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.paypal.com/api/rest/webhooks/#link-eventheadervalidation"},"children":["PayPal"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.zendesk.com/documentation/event-connectors/webhooks/verifying/"},"children":["Zendesk"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://keygen.sh/docs/api/signatures/#webhook-signatures"},"children":["Keygen"]}]}]}]}]}]}]},{"$$mdtype":"Tag","name":"hr","attributes":{},"children":[]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Many webhook vendors use hashing and encryption to add security beyond authentication and message integrity. By combining message integrity with timestamps, providers offer a way to validate when calls are made and mitigate replay attacks. In our research, We saw the use of timestamps in conjunction with HMAC — i.e. ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.calendly.com/api-docs/ZG9jOjM2MzE2MDM4-webhook-signatures"},"children":["Calendly"]},", Asymmetric Encryption - ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.paypal.com/api/rest/webhooks/#link-eventheadervalidation"},"children":["PayPal"]},", and JWT/JWK/OAuth — ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.8x8.com/contactcenter/docs/verify-webhook-callbacks"},"children":["8x8"]},". Timestamp generation and validation takes the following steps:"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["On webhook requests, the provider:"]},{"$$mdtype":"Tag","name":"ol","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Concatenates the timestamp of the request creation with the webhook payload"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Signs the concatenated value"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Sends both the encoded signature and the timestamp to the webhook request"]}]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["The webhook listener receives the request and:"]},{"$$mdtype":"Tag","name":"ol","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Extracts the timestamp — i.e., from the request header — and validates if the timestamp is within an acceptable timeframe (i.e., 3-5 minutes)."]},{"$$mdtype":"Tag","name":"Fence","attributes":{"language":"js"},"children":["  ...\n  const timestampHeader = 'Request-Timestamp'\n  app.post('/webhook', (req, res) => {\n    // Request timestamp in unix date 1000;\n    const requestTimestamp = req.get(timestampHeader) * 1000;\n    // Tolerance zone: 5 minutes ago\n    const tolerance = Date.now() - (5 * 60 * 1000);\n    if (requestTimestamp < tolerance) {\n      // The request timestamp is outside of the tolerance zone.\n      res.status(403).send('Request expired')\n    }else{\n      // The request timestamp is in the tolerance zone.\n      ...\n"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["If the timestamp is valid, repeat the same steps from the webhook provider to sign the request and compare the results with the signature sent:"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"language":"js"},"children":["...\nconst signatureHeader = 'Signature-Header'\nconst signatureAlgorithm = 'sha256'\nconst encodeFormat = 'hex'\nconst hmacSecret = process.env.WEBHOOK_SECRET\nconst timestampHeader = 'Request-Timestamp'\napp.post('/webhook', (req, res) => {\n  ...\n  if (requestTimestamp < tolerance) {\n    // The request timestamp is outside of the tolerance zone.\n    ...\n  }else{\n    // The request timestamp is in the tolerance zone.\n    // Create digest with payload+timestamp+hmac secret\n    const hashPayload = req.rawBody+'.'+req.get(timestampHeader)\n    const hmac = crypto.createHmac(signatureAlgorithm, hmacSecret)\n    const digest = Buffer.from(signatureAlgorithm + '=' + hmac.update(hashPayload).digest(encodeFormat), 'utf8')\n    // Get hash sent by the provider\n    const providerSig = Buffer.from(req.get(signatureHeader) || '', 'utf8')\n    // Compare digest signature with signature sent by provider\n    if (providerSig.length !== digest.length || !crypto.timingSafeEqual(digest, providerSig)) {\n      res.status(401).send('Request unauthorized')\n    }else{\n      // Webhook Authenticated \n      // process and respond\n      res.json({ message: \"Success\" })\n    }\n  }\n})\n"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["If the result matches, the request is considered legit. If not, the request is considered unauthenticated, or its content and timestamp are modified."]}]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"important-notes"},"children":["Important Notes"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["to avoid requests with tampered timestamps, webhook providers must include the timestamp in the signature digest:"]},{"$$mdtype":"Tag","name":"Fence","attributes":{"language":"js"},"children":["const hashPayload = req.rawBody+'.'+req.get(timestampHeader)\n"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["To ensure the timestamp validation works, you must keep your listener clock in sync with the webhook provider. The use of an NTP server should address this concern."]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Some webhook providers — like ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.8x8.com/contactcenter/docs/verify-webhook-callbacks"},"children":["8x8"]}," and ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.paypal.com/api/rest/webhooks/#link-eventheadervalidation"},"children":["PayPal"]}," — also send unique ids per webhook notification. While this gives webhook consumers a way to ensure idempotency, it also requires consumers to store and keep track of webhook ids previously processed."]}]}]}],"frontmatter":{"title":"Replay prevention","description":"Learn how webhook providers leverage signed timestamps to mitigate replay attacks"},"file":{"path":"/security/replay-prevention.md"}}},"__N_SSG":true}