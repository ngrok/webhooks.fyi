{"pageProps":{"markdoc":{"content":[{"$$mdtype":"Tag","name":"table","attributes":{},"children":[{"$$mdtype":"Tag","name":"thead","attributes":{},"children":[]},{"$$mdtype":"Tag","name":"tbody","attributes":{},"children":[{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Complexity"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["High"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Pros"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Extends HMAC with Non-Repudiation (ensures webhook calls can be sent only by the webhook provider)"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Caveats"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Additional deployment complexity (compared to HMAC)"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Additional operational complexity to issue, renew, and rotate keys"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Additional performance concerns with signing and validating signatures (compared to HMAC)"]}]}]}]},{"$$mdtype":"Tag","name":"tr","attributes":{},"children":[{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Examples"]}]},{"$$mdtype":"Tag","name":"td","attributes":{},"children":[{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://docs.sendgrid.com/for-developers/tracking-events/getting-started-event-webhook-security-features"},"children":["SendGrid"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://developer.paypal.com/docs/api-basics/notifications/webhooks/notification-messages/#event-headers"},"children":["PayPal"]}]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://keygen.sh/docs/api/signatures/#webhook-signatures"},"children":["Keygen"]}]}]}]}]}]}]},{"$$mdtype":"Tag","name":"hr","attributes":{},"children":[]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["In our research, we found a few providers — such as PayPal and SendGrid — using asymmetric keys for signing for webhook messages. In this method, the webhook provider uses a private key to sign requests while the listener uses a public key to validate webhook calls. At a conceptual level, the process works as follows:"]},{"$$mdtype":"Tag","name":"ol","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["On webhook requests, the provider signs the webhook message using its private key and adds the signature to the webhook request as a header."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["The webhook listener receives the request and runs an EdDSA, ECDSA or RSA verifier with the public key, the request body, and the signed value from the provider. If the verifier returns positive, it means that the private key could only create the signature, and the request is considered legit."]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"asymmetric-key-signatures-vs-hmac"},"children":["Asymmetric key signatures vs HMAC"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["The major difference between HMAC and asymmetric key signatures is in the verification process. In HMAC, webhook listeners generate the same signature from the provider using the same key to validate the request. With asymmetric signatures, listeners cannot generate the same signature. Instead, they use a verifier with the public key to confirm if the request is legit."]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["This difference in verification logic delivers non-repudiation. In HMAC, anyone with access to the private key can generate a webhook request. However, with asymmetric keys, only the webhook provider — in possession of the private key — can sign webhook messages."]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Webhook implementations with asymmetric keys can also use the same techniques as HMAC providers to add ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"/security/replay-prevention"},"children":["replay prevention"]},", ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"/ops-experience/versioning"},"children":["versioning"]},", and ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"/ops-experience/key-rotation"},"children":["key rotation"]},". SendGrid, for example, implements a timestamp header ( ",{"$$mdtype":"Tag","name":"code","attributes":{},"children":["X-Twilio-Email-Event-Webhook-Timestamp"]}," ) within the payload to mitigate replay attacks."]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"drawbacks"},"children":["Drawbacks"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["However, webhook signatures with asymmetric keys come with drawbacks. Asymmetric keys are considerably harder to implement than HMAC due to the following:"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Many different methods for shipping and rotating public keys"]},": PayPal sends the public key with the webhook request for verification, while SendGrid informs the public key in its settings page. Some other vendors ship asymmetric keys via proprietary APIs and using ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"/security/jwt-jwk-oauth2"},"children":["JSON Web Keys / JWK"]}," APIs."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Different key formats"]},": Providers may ship keys in different formats, including PKCS8, PEM, or CER."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Library support"]},": Compared to HMAC, asymmetric key signatures introduce additional complexity with libraries for validation."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Performance concerns"]},": Signing and validating webhook payloads with asymmetric keys is computationally more expensive than using hashing functions (like SHA-256 in HMAC). While performance may not be an issue for most consumers, it is a crucial item for providers that need to keep performance while sending webhook notifications for multiple destinations with different keys."]}]}],"frontmatter":{"title":"Asymmetric Key Signature (EdDSA, ECDSA and RSA)","description":"With Asymmetric Key Signatures, webhook providers use a private key to sign requests and listeners use a public key to validate webhook calls"},"file":{"path":"/security/asymmetric-key-signatures.md"}}},"__N_SSG":true}