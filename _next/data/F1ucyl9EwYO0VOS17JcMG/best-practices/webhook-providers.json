{"pageProps":{"markdoc":{"content":[{"$$mdtype":"Tag","name":"h2","attributes":{"id":"provide-amazing-documentation"},"children":["Provide amazing documentation"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["In webhook communications, the authentication, message integrity validation, and replay prevention validation, and enforcement happen on the webhook listener. Therefore, webhook providers must simplify the work on developers by providing documentation with:"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Complete specs on your webhook security,"]}," including the authentication mode, cipher suite, signature procedure, and best practices for security."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["A description of the steps to validate your webhook messages"]},"."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["A sample code"]}," (not a pseudo-code) developers can run to understand how webhook notifications should be processed"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Instructions on how developers can test your webhooks"]}," against their code running on localhost"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":[{"$$mdtype":"Tag","name":"strong","attributes":{},"children":["Provide a mechanism to trigger, test, and replay webhooks calls"]}," with a close feedback loop"]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"implement-security-on-egress-communication"},"children":["Implement security on egress communication"]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Webhook integrations seem simple to secure at the surface. However, webhook URLs can be explored by malicious actors — acting as legitimate webhook consumers — to carry out Distributed Denial of Service (DDoS), Server Site Request Forgery (SSRF), and other attacks to the provider infrastructure as described by ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://news.ycombinator.com/item?id=32518208"},"children":["cuu508"]},":"]},{"$$mdtype":"Tag","name":"blockquote","attributes":{},"children":[{"$$mdtype":"Tag","name":"p","attributes":{},"children":["There are some interesting attack vectors to be aware of if you run a service where users can define webhooks, and your service will call the user-defined webhooks to notify about certain system events. In my case, a monitoring service which can send notifications by calling user-defined webhook."]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Timeouts: the user can set up a webhook receiver that takes very long to generate a response. Your service must be able to deal with that."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Timeouts (slowloris): the webhook target could be sending back one byte at a time, with 1 second pauses inbetween. If you are using, say, the \"requests\" python library for making HTTP requests, the \"timeout\" parameter will not help here"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Private IPs and reserved IPs: you probably don't want users defining webhooks to http://127.0.0.1:<some-port> and probing your internal network. Remember about private IPv6 ranges too"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Domains that resolve to private IPs: attacker could set up foo.com which resolves to a private IP. It is not enough to just validate webhook URLs when users set them up."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["HTTP redirects to private IPs. If your HTTP client library follows HTTP redirects, the attacker can set up a webhook endpoint that redirects to a private IP. Again, it is not enough to validate the user-supplied URL."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Excessive HTTP redirects. The attacker can set up a redirect loop - make sure this does not circumvent your timeout setting."," ","My current solution for all of the above is to use libcurl via pycurl. I wrote a wrapper that mimics requests API: https://github.com/healthchecks/healthchecks/blob/master/hc/... (may contain bugs, use at your own risk :-)"]}]}]},{"$$mdtype":"Tag","name":"p","attributes":{},"children":["Webhook providers must implement security controls to mitigate these issues. This can be done at the code level or by using egress proxies for webhook traffic such as ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://github.com/juggernaut/webhook-sentry"},"children":["webhook-sentry"]}," and ",{"$$mdtype":"Tag","name":"a","attributes":{"href":"https://github.com/stripe/smokescreen"},"children":["smokescreen"]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"secret-keys"},"children":["Secret keys"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Consider using asymmetric keys for non-repudiation"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Consider individualizing secret keys per listener"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Implement a key rotation with zero downtime (i.e., signing webhook messages with multiple keys) so webhook listeners can rotate keys regularly. You can also automate the key rotation by implementing APIs that listeners can call to fetch new keys autonomously."]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"encryption-and-hashing-algorithm"},"children":["Encryption and hashing algorithm"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Do not use old ciphers or hashing algorithms such as SHA-1 and MD5."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["For HMAC, use at least SHA-256"]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"signature-payload"},"children":["Signature Payload"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Concatenate body, timestamp, and sensitive headers to form the payload."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Don't add unnecessary steps to the signature, such as changing the payload capitalization and adding line breaks."]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"replay-prevention"},"children":["Replay Prevention"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Timestamps provides a simple way to validate if requests have been sent recently and reduce the risk of message replays."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["When adopting timestamps, consider using Unix timestamp as format (7 of 10 webhook providers), and provide a recommendation of how long messages should be considered valid in your documentation."]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Also, ensure to include the timestamp on the message integrity verification to reduce the risk of tampering."]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"versioning"},"children":["Versioning"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["All security implementations are subject to new vulnerabilities. Consider adding a version header to your webhook messages or the hash signature to provide forward compatibility"]}]},{"$$mdtype":"Tag","name":"h2","attributes":{"id":"compensatory-controls"},"children":["Compensatory controls"]},{"$$mdtype":"Tag","name":"ul","attributes":{},"children":[{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Whenever possible, list the IP origins for webhook messages. This information allows developers to implement IP policies in their listeners for additional security"]},{"$$mdtype":"Tag","name":"li","attributes":{},"children":["Provide a convenient way for listeners to verify the validity of a webhook call, such as including a webhook receipt URL/API within the webhook message."]}]}],"frontmatter":{"title":"Best Practices for Webhook Providers","description":"Security Best Practices for Webhook Providers"},"file":{"path":"/best-practices/webhook-providers.md"}}},"__N_SSG":true}